---
title: "HW1"
format: html
editor: visual
---

## Problem 1

### Part a. Import abalone.data file into a data frame

```{r}
data <- read.table ("abalone.data", header = FALSE, sep = ",")
head(data)
```


### Part b. Number of observations belonging to each sex.

```{r}
table(data[, 1])
sex_observations <- table(data[, 1])
```


### Part c. 
1. weight with the highest correlation to rings

```{r}
weight_cor <- sapply(data[, 5:8], function(x) cor(x, data[, 9]))
top_weight <- names(weight_cor)[which.max(weight_cor)]
top_weight
```

Column 8 (V8) is the Abalon's ShellWeight


2. Sex of that weight with the highest correlation

```{r}
sex_groups <- split(data, data[, 1])
sex_cor <- sapply(sex_groups, function(df) cor(df[[top_weight]], df[, 9]))
top_sex <- names(sex_cor)[which.max(sex_cor)]
top_sex
```

Infants (I) have the weight with the highest correlation


 3. Weight of abalone with highest rings

```{r}
max_rings_row <- data[which.max(data[, 9]), ]
abalone_max_rings <- max_rings_weights <- max_rings_row[, 5:8]
abalone_max_rings
```

The weights of the abalone with the most rings is listed above.


4. Percentage of abalones with a viscera weight larger than shell weight?

```{r}
count <- sum(data[, 7] > data[, 8]) # rows with V7 > V8
total <- nrow(data) # all rows
print(percentage <- (count / total) * 100) # percentage calculation
```

Percentage of abalones with viscera weight larger than shell weight is 6.511%


### Part d. Table of correlations
Working without table column headers is very annoying, I added the table headers


```{r}
colnames(data) <- c("Sex", "Length", "Diameter", "Height", 
                    "WholeWeight", "ShuckedWeight", 
                    "VisceraWeight", "ShellWeight", "Rings")


sex_groups <- split(data, data$Sex) 
cor_table <- sapply(sex_groups, function(df) {
  sapply(df[, 5:8], function(x) cor(x, df$Rings))
}) # Compute correlations: rows = sexes, columns = weights

# Transpose to make rows = sexes, columns = weights
print(cor_table <- t(cor_table))
```
The correlations of weights and rings for each sex is above.


### Part e. Statistical t test

```{r}
p_FM <- t.test(data$Rings[data$Sex == "F"], data$Rings[data$Sex == "M"])$p.value
p_FI <-t.test(data$Rings[data$Sex == "F"], data$Rings[data$Sex == "I"])$p.value
p_MI <-t.test(data$Rings[data$Sex == "M"], data$Rings[data$Sex == "I"])$p.value
c(p_FM, p_FI, p_MI)
```

All p-values of the t-test are < 0.5, which means there is a sgnificant diffrence in # of rings between all sexes and each other.


## Problem 2

### Part a. Import data file into a data frame


```{r}
data2 <- read.csv("/Users/bassiouny/RLearning/506practice/data_prob2.csv")
head(data2)
nrow(data2)
```


### Part b. Change header names

```{r}
names(data2) <- c("ID", "Age", "# Household Individuals", "State", "Currency", "$/last week", "$/grocery", "$/dinning", "$/miscellaneous", "# of outings", "Alcohol Included", "# Food assistance programs")
```

I changed up the header names as seen above.


### Part c. Restrict the data to those paying in US dollars (USD).

```{r}
data_usd <- data2[data2$Currency == "USD", ]
nrow(data2)
sum(data2$Currency == "USD")
```

The analysis shows total number of observations/rows is 262 and total number of observations with USD as the payment is 230. 

### For all the next parts d-h, I am leaving any empty entries in any rows because other correlations can be made using that data.

### Part d. Age clean up

I cleaned up age to exclude entries >= 16 years

```{r}
age_clean <- data_usd[data_usd$Age >= 16, ]
nrow(data_usd)
nrow(age_clean)
```

People under the age of 16 will usually not buy a lot of groceries for their household using their own money. The total number of entries after is 217.


### Part e. State clean up

I am filtering out any states that was noted in just one observation

```{r}
table(age_clean$State)
state_counts <- table(age_clean$State)
state_clean <- age_clean[age_clean$State %in% names(state_counts[state_counts > 1]), ]
nrow(state_clean)
```
When I cleaned up the states, I was left with 201 entries with states mentioned more than once.

### Part f. The four variables related to food expenditures.

First, any entries in the negative were removed

```{r}
negative_clean <- state_clean[!(state_clean[,6] < 0 | state_clean[,7] < 0 | state_clean[,8] < 0 | state_clean[,9] < 0), ]
nrow(negative_clean)
```

After removing all entries with a negative value, I was left with 170 entries.


Now I want to remove any rows where $ spent on anything was larger than total $ spent on food expenditures (column 6).


```{r}
expenditures_clean <- negative_clean[rowSums(negative_clean[,7:9] > negative_clean[,6]) == 0, ]
nrow(expenditures_clean)
```

Now I am left with 83 rows where the amount of spending in any category is less than the total amount of money spent.

### Part g. # of outings

I am going to remove any entries where # of outings were more than 15 times last week. I think this is abnormal and might screw up the analysis.

```{r}
outings_clean <- expenditures_clean[expenditures_clean[,10] <= 15, ]
nrow(outings_clean)
```

Now we are left with 81 entries.

### Part h. # of observations left

From an initial data set of 262 observations to a final row count of 81 after clean up.


## Problem 3

### Part a. write nextCollatz function

```{r}
#' nextCollatz function
#'
#' Given a positive integer n,
#' - If n is even, the next number is n / 2
#' - If n is odd, the next number is 3 * n + 1
#'
#' @param n A positive integer
#' @return The next positive integer in the Collatz sequence
#' @export
nextCollatz <- function(n) {
  # Check for valid input
  if (!is.numeric(n) || length(n) != 1 || n <= 0 || n != floor(n)) {
    message("Invalid input: must be a single positive integer. Returning NA.")
    return(NA)
  }
  
  # Compute next Collatz number
  if (n %% 2 == 0) {
    return(n / 2)
  } else {
    return(3 * n + 1)
  }
}
nextCollatz(5)
nextCollatz(16)
nextCollatz(8)
nextCollatz(-8)
```

As can be seen, all entries give a right output and when the input was a negative entry, invalid input message was generated. 


### Part a. write a Collatz sequence function

```{r}
#' Collatz sequence for a given number
#'
#' Given a positive integer n, this function computes the entire Collatz sequence
#' starting at n and ending at 1.
#'
#' @param n A positive integer
#' @return A list with two elements:
#'   \describe{
#'     \item{sequence}
#'     \item{length}
#'   }
#' @export
collatzSequence <- function(n) {
  if (!is.numeric(n) || length(n) != 1 || n <= 0 || n != floor(n)) {
    message("Invalid input: must be a single positive integer. Returning NA.")
    return(list(sequence = NA, length = NA))
  }
  
  seq <- n
  
  while (tail(seq, 1) != 1) {
    next_val <- nextCollatz(tail(seq, 1))
    seq <- c(seq, next_val)
  }
  
  # Return list with sequence and its length
  return(list(sequence = seq, length = length(seq)))
}

collatzSequence(5)
collatzSequence(19)
collatzSequence(-5)
```