---
title: "HW5"
format: html
editor: visual
---

### Github URL: https://github.com/aelbass/STATS506_HW1.git

## Problem 1

### a. Create a class to represent Wald-style normal approximation Confidence Intervals

```{r}
# Define the S4 class
setClass(
  "waldCI",
  slots = list(
    mean = "numeric",
    sterr = "numeric",
    level = "numeric",
    lb = "numeric",
    ub = "numeric"
  ),
  validity = function(object) {
    if (object@level <= 0 || object@level >= 1)
      return("Confidence level must be between 0 and 1.")
    if (object@sterr < 0)
      return("Standard error must be non-negative.")
    if (object@lb >= object@ub)
      return("Lower bound must be less than upper bound.")
    TRUE
  }
)

# Custom Constructor
createWaldCI <- function(level, mean = NA, sterr = NA, lb = NA, ub = NA) {
  # Check confidence level first
  if (level <= 0 || level >= 1) stop("Confidence level must be between 0 and 1.")

  # Case 1: mean and sterr provided
  if (!is.na(mean) && !is.na(sterr)) {
    if (sterr < 0) stop("Standard error must be non-negative.")
    z <- qnorm(1 - (1 - level) / 2)
    lb <- mean - z * sterr
    ub <- mean + z * sterr
  } 
  # Case 2: lower and upper bounds provided
  else if (!is.na(lb) && !is.na(ub)) {
    if (!is.finite(lb) || !is.finite(ub)) stop("Bounds must be finite.")
    if (lb > ub) stop("Lower bound cannot be greater than upper bound.")
    mean <- (lb + ub) / 2
    z <- qnorm(1 - (1 - level) / 2)
    sterr <- (ub - mean) / z
  } 
  else {
    stop("Provide either (mean, sterr) or (lb, ub).")
  }

  # Create object
  obj <- new("waldCI", mean = mean, sterr = sterr, level = level, lb = lb, ub = ub)
  validObject(obj)
  obj
}

# ShowMethod
setMethod("show", "waldCI", function(object) {
  cat("Wald-style Confidence Interval (Normal Approximation)\n")
  cat(sprintf("Level: %.1f%%\n", object@level * 100))
  cat(sprintf("Mean: %.4f  SE: %.4f\n", object@mean, object@sterr))
  cat(sprintf("CI: [%.4f, %.4f]\n", object@lb, object@ub))
})

# Accessors
setGeneric("lb", function(object) standardGeneric("lb"))
setMethod("lb", "waldCI", function(object) object@lb)

setGeneric("ub", function(object) standardGeneric("ub"))
setMethod("ub", "waldCI", function(object) object@ub)

setMethod("mean", "waldCI", function(x, ...) x@mean)

setGeneric("sterr", function(object) standardGeneric("sterr"))
setMethod("sterr", "waldCI", function(object) object@sterr)

# Setters
setGeneric("level", function(object) standardGeneric("level"))
setMethod("level", "waldCI", function(object) object@level)
setGeneric("lb<-", function(object, value) standardGeneric("lb<-"))
setReplaceMethod("lb", "waldCI", function(object, value) {
  object@lb <- value
  validObject(object)
  object
})

setGeneric("ub<-", function(object, value) standardGeneric("ub<-"))
setReplaceMethod("ub", "waldCI", function(object, value) {
  object@ub <- value
  validObject(object)
  object
})

setGeneric("mean<-", function(x, value) standardGeneric("mean<-"))
setReplaceMethod("mean", "waldCI", function(x, value) {
  x@mean <- value
  validObject(x)
  x
})

setGeneric("sterr<-", function(object, value) standardGeneric("sterr<-"))
setReplaceMethod("sterr", "waldCI", function(object, value) {
  object@sterr <- value
  validObject(object)
  object
})

setGeneric("level<-", function(object, value) standardGeneric("level<-"))
setReplaceMethod("level", "waldCI", function(object, value) {
  object@level <- value
  validObject(object)
  object
})

# A contains method
setGeneric("contains", function(object, value) standardGeneric("contains"))
setMethod("contains", signature("waldCI", "numeric"),
          function(object, value) {
            value >= object@lb & value <= object@ub
          })

# An overlap method
setGeneric("overlap", function(ci1, ci2) standardGeneric("overlap"))
setMethod("overlap", signature("waldCI", "waldCI"),
          function(ci1, ci2) {
            !(ci1@ub < ci2@lb || ci2@ub < ci1@lb)
          })

# as.numeric
setMethod("as.numeric", "waldCI",
          function(x) c(x@lb, x@ub))

# Transform CI
setGeneric("transformCI", function(object, f) standardGeneric("transformCI"))
setMethod("transformCI", signature("waldCI", "function"),
          function(object, f) {
            warning("Only monotonic transformations preserve interval meaning.")
            new_lb <- f(object@lb)
            new_ub <- f(object@ub)
            new_mean <- f(object@mean)
            createWaldCI(level = object@level, lb = new_lb, ub = new_ub)
          })
```


### b. Evaluate the code

```{r}
ci1 <- createWaldCI(level = 0.95, lb = 17.2, ub = 24.7)
ci2 <- createWaldCI(level = 0.99, mean = 13, sterr = 2.5)
ci3 <- createWaldCI(level = 0.75, lb = 27.43, ub = 39.22)

ci1
ci2
ci3
as.numeric(ci1)
as.numeric(ci2)
as.numeric(ci3)
lb(ci2)
ub(ci2)
mean(ci1)
sterr(ci3)
level(ci2)
lb(ci2) <- 10.5
mean(ci3) <- 34
level(ci3) <- .8
contains(ci1, 17)
contains(ci3, 44)
overlap(ci1, ci2)
eci1 <- transformCI(ci1, sqrt)
eci1
mean(transformCI(ci2, log))
```

### c. Show that your validator does not allow the creation of invalid confidence intervals

```{r}
#negative standard error
try(ci_invalid1 <- createWaldCI(level = 0.95, mean = 10, sterr = -2))

# lb > ub
try(ci_invalid2 <- createWaldCI(level = 0.95, lb = 20, ub = 15))

# Infinite bounds
try(ci_invalid3 <- createWaldCI(level = 0.95, lb = -Inf, ub = 15))

# invalid use of the setters
ci_valid <- createWaldCI(level = 0.95, mean = 10, sterr = 2)
try(level(ci_valid) <- 1.5)
```

Just a note, I add the righ error messages to the custom constructor instead of just having them in the validty for the class creation, so the right messages appear accordingly without triggering earlier errors ahead.


## Problem 2

### a. How many major and minor spikes in cases were there?

```{r}
library(tidyverse)
library(dplyr)
library(readr)
covid_cases <- read_csv("us-states.csv")
covid_cases <- covid_cases %>%
  mutate(date = as.Date(date))

library(plotly)
p <- plot_ly(
  data = covid_cases,
  x = ~date,
  y = ~cases_avg_per_100k,
  color = ~state,
  type = "scatter",
  mode = "markers",
  marker = list(size = 3, opacity = 0.5)
)

# Add layout
p <- layout(
  p,
  title = list(
    text = "COVID-19 Case Trends Across U.S. States"
  ),
  xaxis = list(title = "Date"),
  yaxis = list(title = "Cases per 100k"),
  legend = list(title = list(text = "State")),
  showlegend = FALSE
)
p
```

From plotting date versus reported cases as shown above, I would say that there are 3 minor (~ April 2020, July 2020 and April 2021) spikes and 4 major spikes (~ Jan. 2021, Aug. 2021, Jan 2022 and June 2022).


### b. For the states with the highest and lowest overall rates per population, what differences do you see in their trajectories over time?

```{r}
covid_state <- covid_cases %>%
  group_by(state) %>%
  summarize(total = sum(cases_avg_per_100k, na.rm = TRUE)) %>%
  ungroup()

# Identify min and max
min_val <- min(covid_state$total)
max_val <- max(covid_state$total)

covid_state <- covid_state %>%
  mutate(
    highlight = ifelse(total == min_val | total == max_val, TRUE, FALSE),
    label_pos = ifelse(total > mean(total), total + 500, total - 500),  # mimic nudge_x
    label_anchor = ifelse(total > mean(total), "left", "right")         # mimic hjust
  )

# Build plot
plot_ly(covid_state) %>%
  add_markers(
    x = ~total,
    y = ~state,
    color = ~highlight,
    colors = c("gray", "red"),
    marker = list(size = 10),
    hoverinfo = "text",
    text = ~paste0(state, "<br>Total: ", round(total))
  ) %>%
  add_text(
    x = ~label_pos,
    y = ~state,
    text = ~state,
    textposition = ~label_anchor,
    showlegend = FALSE
  ) %>%
  layout(
    title = "Total COVID Cases per 100k (Jan 2020 – Mar 2023)",
    xaxis = list(title = "Total COVID cases per 100k"),
    yaxis = list(title = "", showticklabels = FALSE),
    showlegend = FALSE
  )

covid_filtered <- covid_cases %>%
  filter(state %in% c("Maine", "Rhode Island")) %>%
  mutate(date = as.Date(date))

p2 <- plot_ly(covid_filtered, 
             x = ~date, 
             y = ~cases_avg_per_100k, 
             color = ~state, 
             type = 'scatter', 
             mode = 'lines+markers',
             hoverinfo = 'text',
             text = ~paste("State:", covid_filtered$state,
                           "<br>Date:", date,
                           "<br>Cases:", cases_avg_per_100k)) %>%
  layout(
    title = "COVID Cases per 100k",
    xaxis = list(title = "Date", type = "date"),
    yaxis = list(title = "Cases per 100k")
  )

# Display the plot
p2
```

From here we see that Maine and Rhode Island have the lowest and highest overall count, respectively, per population. Cases in Maine were very consistent over the entire period, while a huge spike hit Rhode Island in winter 21-22.

### c. Identify, to the best of your ability without a formal test, the first five states to experience Covid in a substantial way.

```{r}
library(scales)

# Filter data: April to June 2020
start_date <- as.Date("2020-04-01")
end_date <- as.Date("2020-06-01")
covid_apr_jun <- covid_cases %>%
  filter(date >= start_date & date < end_date)

# Keep states with cases_avg_per_100k >= 30 during this period
states_to_keep <- unique(covid_apr_jun$state[covid_apr_jun$cases_avg_per_100k >= 30])

covid_2020_filtered <- covid_cases %>%
  filter(date < end_date & state %in% states_to_keep)

# Create Plotly interactive line plot
p3 <- plot_ly(covid_2020_filtered,
             x = ~date,
             y = ~cases_avg_per_100k,
             color = ~state,
             type = 'scatter',
             mode = 'lines',
             line = list(width = 2),
             hoverinfo = 'text',
             text = ~paste("State:", state,
                           "<br>Date:", date,
                           "<br>Cases:", cases_avg_per_100k)) %>%
  layout(
    title = "COVID-19 Average Cases per 100k (2020) – High Impact States",
    xaxis = list(title = "Date",
                 type = "date",
                 tickformat = "%b",
                 dtick = "M1"),   # monthly ticks
    yaxis = list(title = "Cases per 100k"),
    legend = list(title = list(text = "State"), orientation = "v")  # legend on right
  )

# Display the plot
p3
```

I made a new data set to only include states with 30+ (substantial) cases per 100k between April and June 2020. The spikes started happening around that time, so I picked the date and number of cases per 100k based on that. The first five states to experience Covid in a substantial way were New York, New Jersey, Louisiana, Guam and Rhaode Island. Massachusetts and Connecticut were very close, but I would consider them in the 6th and seventh positions.
