---
title: "HW2"
format: html
editor: visual
---

### Github URL: https://github.com/aelbass/STATS506_HW1.git

## Problem 1

### trying random_walk function
```{r}
#' random_walk function
#'
#' @param n the number of steps
#' @return The final position of the walk
#' @export
random_walk <- function(n_steps) {
  position <- 0
  
  for (i in 1:n_steps) {
    step <- sample(c(-1, 1), 1)  # base direction, 50/50
    
    if (step == 1) {
      # With 5% chance, replace +1 with +10
      if (runif(1) < 0.05) {
        move <- 10
      } else {
        move <- 1
      }
    } else {
      # With 20% chance, replace -1 with -3
      if (runif(1) < 0.20) {
        move <- -3
      } else {
        move <- -1
      }
    }
    
    position <- position + move
  }
  
  return(position)
}
random_walk(10)
random_walk(10)
```


### a.

```{r}
#' random_walk1 function (loop)
#'
#' @param n the number of steps
#' @return The final position of the walk
#' @export
random_walk1 <- function(n_steps) {
  position <- 0
  
  for (i in 1:n_steps) {
    step <- sample(c(-1, 1), 1)  # base direction, 50/50
    
    if (step == 1) {
      # With 5% chance, replace +1 with +10
      if (runif(1) < 0.05) {
        move <- 10
      } else {
        move <- 1
      }
    } else {
      # With 20% chance, replace -1 with -3
      if (runif(1) < 0.20) {
        move <- -3
      } else {
        move <- -1
      }
    }
    
    position <- position + move
  }
  
  return(position)
}

#' random_walk2 function (vectorization)
#'
#' @param n the number of steps
#' @return The final position of the walk
#' @export

random_walk2 <- function(n_steps) {
  # 1. Generate directions (+1 or -1) as in the loop
  directions <- sample(c(-1, 1), n_steps, replace = TRUE)
  
  # 2. Pre-generate a uniform probability for each step
  probs <- runif(n_steps)
  
  # 3. Initialize moves vector
  moves <- numeric(n_steps)
  
  # 4. Vectorized assignment for +1 steps
  plus_idx <- which(directions == 1)
  moves[plus_idx] <- ifelse(probs[plus_idx] < 0.05, 10, 1)
  
  # 5. Vectorized assignment for -1 steps
  minus_idx <- which(directions == -1)
  moves[minus_idx] <- ifelse(probs[minus_idx] < 0.20, -3, -1)
  
  # 6. Return final position
  sum(moves)
}

#' random_walk3 function (apply)
#'
#' @param n the number of steps
#' @return The final position of the walk
#' @export

random_walk3 <- function(n_steps) {
  moves <- sapply(1:n_steps, function(i) {
    step <- sample(c(-1, 1), 1)
    if (step == 1) {
      if (runif(1) < 0.05) 10 else 1
    } else {
      if (runif(1) < 0.20) -3 else -1
    }
  })
  sum(moves)
}

random_walk1(10)
random_walk2(10)
random_walk3(10)
random_walk1(1000)
random_walk2(1000)
random_walk3(1000)
```

### b.Using seed = 25

```{r}
set.seed(25)
random_walk1(10)
set.seed(25)
random_walk2(10)
set.seed(25)
random_walk3(10)
set.seed(25)
random_walk1(1000)
set.seed(25)
random_walk2(1000)
set.seed(25)
random_walk3(1000)
```

### c. timing compariosn

```{r}
# Benchmark
library("microbenchmark")

set.seed(25)
microbenchmark(
  loop = random_walk1(100),
  sapply = random_walk2(100),
  vectorized = random_walk3(100),
  times = 10
)
```

At a 1000 steps

### 100000

```{r}
```

### d.

```{r}

```

## Problem 2

```{r}
N <- 3650  # number of days in 10 years

# Poisson means for 24 hours
lam <- rep(0, 24)
lam[1:8]   <- 1   # hours 0–7
lam[10:17] <- 8   # hours 9–16
lam[19:24] <- 12  # hours 18–23

# Poisson samples (N x 24 matrix)
poisson_samples <- matrix(
  rpois(N * 24, lambda = rep(lam, each = N)),
  nrow = N, ncol = 24, byrow = FALSE
)

# Normal samples for rush hours (8AM and 5PM)
sd <- sqrt(12)
normal_samples <- matrix(
  rnorm(N * 2, mean = 60, sd = sd),
  ncol = 2, byrow = TRUE
)

# Round + clip negatives, stay as matrix
normal_samples <- pmax(0, round(normal_samples))

# Make sure it's still a matrix even if N=1
if (is.null(dim(normal_samples))) {
  dim(normal_samples) <- c(N, 2)
}

# Replace into hour 8 (col 9) and hour 17 (col 18)
poisson_samples[, 9]  <- normal_samples[, 1]
poisson_samples[, 18] <- normal_samples[, 2]

daily_totals <- rowSums(poisson_samples)
mean_daily <- mean(daily_totals)
sd_daily   <- sd(daily_totals)

list(
  mean_daily = mean_daily,
  sd_daily   = sd_daily
)
```
The average number of cars that pass that intersection per day is ~264 +- 13 cars.


## Problem 3

### a. Deidentify data

```{r}
youtube <- read.csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2021/2021-03-02/youtube.csv')
dim(youtube)
colnames(youtube)
youtube1 <- youtube[, -c( 2, 3, 4, 12, 14, 20, 21, 22, 23,24)]
dim(youtube1)
colnames(youtube1)
head(youtube1)
```

I removed all identifiers from the list, the matrix became 247 rows and down to 15 columns from an initial 25-column matrix

### b. variables to be used in regression models

```{r}
hist(youtube1$view_count)
summary(youtube1$view_count)
hist(youtube1$like_count)
summary(youtube1$like_count)
hist(youtube1$dislike_count)
summary(youtube1$dislike_count)
hist(youtube1$favorite_count)
summary(youtube1$favorite_count)
hist(youtube1$comment_count)
summary(youtube1$comment_count)
```

Favorite count could not be appropriate to use as the outcome in a linear regression model since all the values are 0 (maybe binary). All other variables could be used as is as the outcome in a linear regression model.


### c. linear regression models

```{r}
#views
model_views <- lm(view_count ~ funny + show_product_quickly + patriotic + celebrity +
                  danger + animals + use_sex + year, data = youtube1)

summary(model_views)

#likes
model_likes <- lm(like_count ~ funny + show_product_quickly + patriotic + celebrity +
                  danger + animals + use_sex + year, data = youtube1)

summary(model_likes)

#dislikes
model_dislikes <- lm(dislike_count ~ funny + show_product_quickly + patriotic +    celebrity + danger + animals + use_sex + year, data = youtube1)

summary(model_dislikes)

#comments
model_comments <- lm(comment_count ~ funny + show_product_quickly + patriotic + celebrity + danger + animals + use_sex + year, data = youtube1)

summary(model_comments)
```

For the view, like and dislike counts, there is no statistcial difference based on the p-values > 0.05, thus no consistent effect between any of the binary variables and the view_count. 

However, for the comment counts there is a directly positive relationship between patriotic adds and comments with a p value of 0.035. This is the only statistically significantly relationship. 


### d. compute B hat manually

```{r}
# setting up proper matrix
vars_used <- c("view_count", "funny", "show_product_quickly", "patriotic", "celebrity",
               "danger", "animals", "use_sex", "year")
complete_cases <- complete.cases(youtube1[, vars_used])
youtube_complete <- youtube1[complete_cases, ]

X <- model.matrix(view_count ~ funny + show_product_quickly + patriotic + celebrity +
                 danger + animals + use_sex + year, data = youtube_complete)

y <- youtube_complete$view_count

cat("Dimensions of X:", dim(X), "\n")
cat("Length of y:", length(y), "\n")
cat("Number of rows in X equals length of y:", nrow(X) == length(y), "\n")

beta_hat_manual <- solve(crossprod(X), crossprod(X, y))
beta_hat_manual
```

These are same values of B obtained in part C when lm was used.
